# Проект 01 – Python
## Оглавление
1. [Глава I](#глава-i) \
    1.1. [Преамбула](#преамбула)
2. [Глава II](#глава-ii) \
    2.1. [Общая инструкция](#общая-инструкция)
3. [Глава III](#глава-iii) \
    3.1. [Цели](#цели) 
4. [Глава IV](#глава-iv) \
    4.1. [Задание](#задание)
5. [Глава V](#глава-v) \
    5.1. [Сдача работы и проверка](#сдача-работы-и-проверка)

## Глава I
### Преамбула
За последние годы язык программирования Python стал одним из ключевых инструментов для анализа и визуализации больших 
массивов данных. Благодаря своей читабельности, простому синтаксису и отсутствию необходимости в компиляции, Python 
широко используется как в учебных целях, так и в профессиональной среде. Он позволяет сосредоточиться на изучении 
алгоритмов, концепций и парадигм программирования, не перегружая разработчика техническими деталями.

По данным [индекса TIOBE](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_TIOBE), 
Python занимает одно из первых мест среди самых популярных языков программирования в мире. Его востребованность 
особенно заметна в области анализа данных и искусственного интеллекта.

Популярность Python в сфере **Data Science** объясняется в первую очередь богатой экосистемой специализированных 
библиотек и активным сообществом разработчиков. Среди наиболее значимых инструментов можно выделить:

* **NumPy** — для работы с многомерными массивами и векторизованными вычислениями;
* **Pandas** — для обработки и анализа табличных и разнородных данных;
* **SciPy** — для решения задач научных и инженерных вычислений;
* **Matplotlib** — для построения графиков и профессиональной визуализации данных;
* **Scikit-Learn** — для решения задач классического машинного обучения;
* **OpenCV** — для компьютерного зрения: обработки изображений, распознавания объектов и видеоаналитики;
* **PyTorch** — для разработки и обучения нейронных сетей.

Однако применение Python не ограничивается только анализом данных. Он активно используется:

* для **разработки сервисов и приложений** (например, создание REST API с помощью **FastAPI** или **Django**);
* для **автоматизации тестирования** и обеспечения качества кода (библиотеки **pytest**, **unittest** и инструменты для интеграционного тестирования).

Таким образом, Python является универсальным языком, который соединяет исследовательскую работу с данными, 
машинное обучение и инженерные задачи по созданию надёжных сервисов. В ходе курса мы подробно познакомимся как с 
инструментами анализа данных, так и с практиками разработки приложений и тестирования.


## Глава II
### Общая инструкция
Методология Школы 21 может быть не похожа на тот образовательный опыт, который случался с тобой ранее. Её отличает высокий уровень автономии: у тебя есть задача, ты должен её выполнить. По большей части тебе нужно будет самому добывать знания для её решения. Второй важный момент — это peer-to-peer обучение. В образовательном процессе нет менторов и экспертов, перед которыми ты защищаешь свой результат. Ты это делаешь перед таким же учащимися, как и ты сам. У них есть чек-лист, который поможет им качественно выполнить приемку вашей работы.

Роль Школы 21 заключается в том, чтобы обеспечить через последовательность заданий и оптимальный уровень поддержки такую траекторию обучения, при которой ты не только освоишь hard skills, но и научишься самообучаться.

- Не доверяй слухам и предположениям о том, как должно быть оформлено ваше решение. Этот документ является единственным источником, к которому стоит обращаться по большинству вопросов;
- твое решение будет оцениваться другими учащимися;
- подлежат оцениванию только те файлы, которые ты выложил в GIT (ветка develop, папка src);
- в твоей папке не должно быть лишних файлов — только те, что были указаны в задании;
- не забывай, что у вас есть доступ к интернету и поисковым системам;
- обсуждение заданий можно вести и в Rocket.Chat;
- будь внимателен к примерам, указанным в этом документе — они могут иметь важные детали, которые не были оговорены другим способом;
- и да пребудет с тобой Сила!

## Глава III
### Цели
Сегодня большинство задач анализа и обработки данных решаются с помощью библиотек высокого уровня и методов 
искусственного интеллекта. Однако прежде чем углубляться в современные подходы, важно уверенно владеть 
основами языка программирования Python.

В этом проекте мы сосредоточимся на том, чтобы вспомнить синтаксис Python и научиться применять его для решения 
практических задач. Мы будем работать с базовыми структурами данных, циклами, условиями, функциями и классами, а 
также познакомимся с библиотекой NumPy и вспомним о написании тестов для проверки решений. 
В качестве практики попробуем реализовать простые алгоритмы обработки информации своими руками:

* **Создание инвертированного индекса** — задача обработки текстовых данных и поиска информации. 
Поможет вспомнить базовый синтаксис Python
* **Решение Cудоку** — пример работы с матрицами и комбинаторной задачи, где требуется перебор 
и проверка условий для нахождения корректного решения

Эти задания позволят не только закрепить базовые навыки работы с Python, NumPy, но и понять, 
что разнообразные прикладные задачи можно эффективно решать без сложных моделей машинного обучения 
и искусственного интеллекта.

## Глава IV
### Задание
### 0. Подготовка окружения
Для того чтобы эффективно работать с Python, особенно в проектах по Data Science, важно уметь создавать и управлять
виртуальными окружениями. Виртуальное окружение позволяет:
* Изолировать зависимости проекта — разные проекты могут использовать разные версии библиотек, не мешая друг другу;
* Избежать конфликтов версий Python и пакетов;
* Легко переносить и разворачивать проекты на других машинах.

В Python есть несколько способов создать виртуальное окружение, но самым популярным является использование 
встроенного модуля [venv](https://docs.python.org/3/library/venv.html)

#### Задание 0.1. Создание виртуального окружения
* Создай виртуальное окружение с именем **project1**.
* Активируй виртуальное окружение.
* Выведи список библиотек, установленных в новом окружении.
* Сделай скриншот командной строки, чтобы было видно и активное окружение, и список библиотек. Сохрани его в папке [assets](assets).

Сила Python во многом заключается в его богатой экосистеме библиотек. С их помощью можно быстро и эффективно решать 
задачи в Data Science, веб-разработке, автоматизации и многих других областях.

Для установки библиотек используется пакетный менеджер [pip](https://pip.pypa.io/en/stable/), который позволяет скачивать, обновлять 
и управлять зависимостями проекта внутри виртуального окружения.

#### Задание 0.2. Установка библиотек
* Убедись, что твое виртуальное окружение (project1) активировано
* Установи библиотеки `numpy` и `jupyterlab`
* Сохрани список всех установленных библиотек и их версий в файл `requirements.txt`
> **Важно:** загружать само виртуальное окружение на Git не требуется — достаточно хранить файл `requirements.txt`,
> чтобы его можно было использовать для повторного создания окружения.

#### Jupyter Notebooks
[**Jupyter Lab**](https://jupyter.org/) — это мощная среда для интерактивной работы с Python и другими языками 
программирования, которая особенно полезна для анализа данных.
Основные преимущества Jupyter Lab:
* Позволяет запускать код по ячейкам, что удобно для пошаговой проверки результатов;
* Можно сочетать код, текст, формулы (Markdown и LaTeX) и графики в одном документе;
* Широко используется в Data Science и машинном обучении для экспериментов и визуализации данных;
* Поддерживает расширения для работы с Git, визуализацией и интерактивными виджетами.

**Альтернатива: [Google Colab](https://colab.research.google.com/)**

**Google Colab** — это облачная среда, аналогичная Jupyter Notebook, где можно:
* Работать над проектами без установки Python на свой компьютер;
* Использовать бесплатный GPU и TPU для ускорения вычислений;
* Легко делиться проектами и совместно работать с другими.

Запуск Jupyter Lab в активированном виртуальном окружении:
```shell
jupyter lab
```
После запуска откроется веб-интерфейс, где можно создавать и редактировать jupyter-ноутбуки.

Сегодняшние проекты можно выполнять в Jupyter Lab или Google Colab, в зависимости от ваших предпочтений 
и доступности ресурсов.

### 1. Инвертированный индекс
Информационный поиск (Information Retrieval) — это область компьютерных наук, которая изучает методы поиска нужной
информации в больших коллекциях данных. Классический пример — поисковые системы в интернете, которые позволяют найти 
документы, статьи или веб-страницы по ключевым словам.

Цель информационного поиска — не просто найти документы, содержащие слово, но и оценить их релевантность запросу 
пользователя. Одним из основных инструментов в информационном поиске является **инвертированный индекс**.

**Инвертированный индекс** — это структура данных, которая для каждого уникального слова хранит список документов или 
частей текста, где это слово встречается. Проще говоря, он «переворачивает» данные: вместо списка документов с их 
словами создаётся список слов с привязкой к документам.

![inverted_index_scheme.png](misc/inverted_index_scheme.png)

#### Задание 1.1. Разделение на предложения
* Считай текст книги **«Война и мир»** из `.txt` [файла](datasets/war_and_peace.txt)
* Раздели текст на предложения по знакам `. ! ?`, удали пробелы и пустые строки
* Посмотри на полученные предложения и приведи несколько примеров, когда разбиение некорреткное
* Раздели текст на предложения с помощью библиотеки [razdel](https://github.com/natasha/razdel)
* Выведи количество предложений, полученных с помощью `razdel`

#### Задание 1.2. Очистка текста
* Очисти текст от знаков препинания и приведи все слова к **нижнему регистру**
* Разбей каждое предложение на список слов
* Удали **стоп-слова** из [файла](datasets/stop_words_russian.txt)
* Удали все пустые предложения (те, что после очистки не содержат слов)
* Выведи:
  * **количество слов** в самом длинном предложении
  * **общее количество предложений**, оставшихся после очистки.

#### Задание 1.3. Построение инвертированного индекса
Реализуй **инвертированный индекс** для поиска слов в предложениях с помощью класса `InvertedIndex`.

**Что нужно сделать:**

* Реализуй метод `build_index`, который строит индекс из списка документов, где каждый документ — это список слов.
  * Для каждого уникального слова сохраняй список id документов (предложений), в которых оно встречается.
  * Используй атрибут `word2doc` для хранения данных.
* Реализуй метод `save_index`, чтобы **сохранять индекс в файл** (например, с помощью `pickle`) для последующего использования.
* Реализуй метод `load_index`, чтобы **загружать индекс из файла**.
* Реализуй метод `__len__`, который возвращает **количество уникальных слов** в индексе.

**Протестируй работу индекса:**

1. Построй индекс на списке предложений книги.
2. **Сохрани** индекс в файл.
3. **Загрузи** индекс из файла в **новый объект**.
4. Выведи количество **уникальных слов** в загруженном индексе

#### Задание 1.4. Поиск по индексу
* Реализуй метод `query` класса `InvertedIndex`, который выполняет поиск слов в индексе.
* Метод принимает **список слов** и возвращает список id предложений, в которых встречаются **все указанные слова** (операция «и»).
* Результат должен быть **отсортирован по возрастанию** id предложения.
* Проверь работу метода `query` на следующих примерах:
  * Слово: `университет`
  * Слова: `война` и `мир`
  * Слово: `школа`

### 2. Решение судоку
В этом задании ты научишься работать с матрицами и попрактикуешься в использовании библиотеки **NumPy**. 
Мы будем писать простой генератор и валидатор головоломок судоку.


### Задание 3.1. Решение судоку
Теперь, когда ты научился генерировать и проверять матрицы, пора написать **решатель судоку**. 
Это задание поможет тебе попрактиковаться в алгоритмах перебора и рекурсии, а также закрепить работу с тестами.

1. **Напиши функцию-решатель** для судоку 9×9.
   * Можно использовать алгоритм перебора (backtracking).
   * На вход функция получает матрицу с числами от 1 до 9 и пустыми клетками (0).
   * На выходе возвращает полностью решённую матрицу.

2. **Проверь корректность работы решателя.**
   * Напиши минимум **3 юнит-теста** с помощью библиотеки `pytest`.
   * Тесты должны проверять, что твой решатель находит правильное решение для разных входных матриц.

3. **Сравни решение с API.**
   * Используй API [youdosudoku.com](https://www.youdosudoku.com/) для генерации игры в судоку.
   * Запроси новое поле размером 9×9 с простой сложностью.
   * Прогони его через свой решатель.
   * Сравни результат с решением, которое возвращает API.
4. Выведи результат проверки в консоль: совпадает ли решение твоего солвера с эталонным решением.


## Глава V
### Сдача работы и проверка
Сохрани решение в файле 01-assignment.ipynb \
Загрузи изменения на Git в ветку develop.

💡 [Нажми здесь](https://forms.gle/2iayfRoMCXWtVc7Z8) **чтобы отправить обратную связь по проекту**. 

